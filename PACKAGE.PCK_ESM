CREATE OR REPLACE EDITIONABLE PACKAGE "PCK_ESM" as
    --
    PROCEDURE buildESModules(pEsmLibrary IN VARCHAR2 DEFAULT 'test');
    --
end;
/
CREATE OR REPLACE EDITIONABLE PACKAGE BODY "PCK_ESM" as

    /*
    ** TO CREATE NEW ES MODULE -
    **
    ** 1. Upload and minify module in APEX
    ** 2. insert into es_modules(module_name, deploy_envs) values ('deploy_edited-content.min.js', 1);
    */

    PROCEDURE buildESModules(pEsmLibrary IN VARCHAR2) IS 
        l_files JSON_OBJECT_T;

        TYPE tt_files IS RECORD (
            file_name apex_application_static_files.file_name%type,
            file_content CLOB
        );
        TYPE t_files IS TABLE OF tt_files INDEX BY VARCHAR2(40);
        l_deploy_files t_files;

        -- l_headers CLOB;
        
        l_sha1_test es_modules.sha1_test%type;
        
        l_clob CLOB;
        l_website_id website.id%type;
        l_netlify_site_id website.netlify_site_id%type;
        l_user_id website.user_id%type;
        l_ssl_url VARCHAR2(50);
        l_netlify_deploy_id website.netlify_deploy_id%type;

        l_file_content CLOB;
        l_filename VARCHAR2(250);
        l_sha1 VARCHAR2(40);
        l_rebuild_importmaps NUMBER:=0;
        n PLS_INTEGER:=0;

        PROCEDURE addDeploy(pFilename IN VARCHAR2, pFileContent IN OUT NOCOPY CLOB) IS
            l_sha1 website_files.sha1%type;
        BEGIN
            dbms_output.put_line('Adding new or changed file to deployment - '|| pFilename);
            l_sha1:=LOWER(dbms_crypto.hash(src => pFileContent, typ => dbms_crypto.hash_sh1));
            l_deploy_files(l_sha1).file_name:=pFilename;
            l_deploy_files(l_sha1).file_content:=pFileContent;
            l_files.put(pFilename, l_sha1);
        END;

        /*
        **  BUILD "test" LIBRARY IMPORTMAPS WHEN NEW MODULE ADDED OR MODULE NAME CHANGED
        */
        PROCEDURE buildImportmaps IS
            l_importmap CLOB;
            l_sha1 VARCHAR2(40);
            l_filename VARCHAR2(100);
        BEGIN
            FOR C IN (
                WITH data AS
                (
                    SELECT SUBSTR(module_name,1,INSTR(module_name,'.')-1) AS module_name, 
                            l_ssl_url || '/test/javascript/' || module_name AS host_name
                      FROM es_modules
                ),
                json AS
                (
                    SELECT json_object(
                             'imports' VALUE json_objectagg(module_name VALUE host_name)
                             returning clob) AS content
                      FROM data
                ),
                source AS
                (
                    SELECT 'test/importmap.json' AS deploy_filename, sha1_live
                      FROM es_modules_importmap
                )
                SELECT s.deploy_filename, s.sha1_live, j.content, f.sha1
                  FROM source s, json j, website_files f
                 WHERE f.website_id(+)=l_website_id
                   AND f.path(+)=s.deploy_filename
            ) LOOP
                l_sha1:=LOWER(dbms_crypto.hash(src => C.content, typ => dbms_crypto.hash_sh1));
                IF (C.sha1 IS NULL OR C.sha1<>l_sha1) THEN
                    UPDATE es_modules_importmap SET sha1_test=l_sha1;
                    addDeploy(C.deploy_filename, C.content);
                ELSE
                    l_files.put(C.deploy_filename, C.sha1);
                END IF;
                IF (C.sha1_live IS NOT NULL) THEN
                    l_files.put(REPLACE(C.deploy_filename,'test','live'), C.sha1_live);
                END IF;
            END LOOP;
        END;

        /* 
        ** SEND TO NETLIFY LIST OF SHA1 OF EACH FILE IN THE DEPLOYMENT 
        */
        PROCEDURE sendNetlifyDeploy IS
            l_json JSON_OBJECT_T;
            l_keys JSON_KEY_LIST;
            l_filename VARCHAR2(200);
            l_sha1 VARCHAR2(40);
            l_clob CLOB;
        BEGIN
            l_json:= new JSON_OBJECT_T;
            l_json.put('files',l_files);

            pck_api.callNetlifyAPI(pUserId=>null, pEndpoint=>'sites/' || l_netlify_site_id || '/deploys', pMethod=>'POST', pBody=>l_json.stringify, pData=>l_clob);

            /* NEED THIS FOR ASYNC DEPLOYMENT STATUS MONITORING */
            UPDATE website SET netlify_deploy_id=(SELECT id FROM JSON_TABLE(l_clob, '$' COLUMNS (id))) WHERE id=l_website_id;
            COMMIT;

            FOR C IN (SELECT id, sha1 FROM JSON_TABLE(l_clob, '$' COLUMNS (id, NESTED '$.required[*]' COLUMNS (sha1 PATH '$'))) WHERE sha1 IS NOT NULL) LOOP
                dbms_output.put_line('Uploading ' || l_deploy_files(C.sha1).file_name);
                IF (l_deploy_files(C.sha1).file_content IS NOT NULL) THEN
                    pck_api.callNetlifyAPI(pUserId=>null, pEndpoint=>'deploys/' || C.id || '/files/' || l_deploy_files(C.sha1).file_name, pMethod=>'PUT', pBody=>l_deploy_files(C.sha1).file_content,pData=>l_clob);
                ELSE
                    RAISE_APPLICATION_ERROR(-20090,'Logic error - file_content is null');
                END IF;
            END LOOP;

            /* 
            ** UPDATE WEBSITE_FILES WITH THIS SITE DEPLOYMENT 
            */
            DELETE website_files WHERE website_id=l_website_id AND site_id=l_netlify_site_id;
            l_keys:=l_files.get_keys;
            FOR i in 1..l_keys.COUNT LOOP
                l_filename:=l_keys(i);
                l_sha1:=l_files.get_string(l_keys(i));
                INSERT INTO website_files(website_id, site_id, path, sha1, mime_type)
                VALUES (l_website_id, l_netlify_site_id, l_filename, l_sha1, SUBSTR(l_filename,INSTR(l_filename,'.',-1)+1));
            END LOOP;
        END;

    BEGIN
        IF (pEsmLibrary NOT IN ('test','live')) THEN
            RAISE_APPLICATION_ERROR(-20100,'Environment must be "live" or "test"');
            RETURN;
        END IF;

        SELECT id, netlify_site_id, user_id INTO l_website_id, l_netlify_site_id, l_user_id 
          FROM website
         WHERE domain_name='es-modules';

        l_ssl_url:='https://es-modules.netlify.app';

        l_files:= new JSON_OBJECT_T;

        FOR C IN (
            WITH source AS
            (
                SELECT e.module_name, 'test/javascript/' || e.module_name AS deploy_filename, e.sha1_test, e.sha1_live, e.deploy_envs, CAST(s.last_updated_on AS TIMESTAMP WITH TIME ZONE) updated_date
                  FROM es_modules e, apex_application_static_files s
                 WHERE s.file_name=e.module_name
                   AND s.application_id=101
            )
            SELECT s.deploy_filename, s.module_name, s.sha1_test, s.sha1_live, s.updated_date, s.deploy_envs,
                    CASE WHEN f.deployed_date IS NULL OR s.updated_date>f.deployed_date THEN 1 ELSE 0 END build
              FROM source s, website_files f
             WHERE f.website_id(+)=l_website_id
               AND f.path(+)=s.deploy_filename
        ) LOOP
            IF (pEsmLibrary='live') THEN
                UPDATE es_modules
                   SET sha1_live=C.sha1_test,
                       updated_live=current_timestamp
                 WHERE module_name=C.module_name;
                l_files.put(C.deploy_filename, C.sha1_test);
                l_files.put(REPLACE(C.deploy_filename,'test','live'), C.sha1_test);
                CONTINUE;
            END IF;

            /*
            ** UPDATING "test" LIBRARY. 
            ** ALWAYS RE-DEPLOY THE CURRENT "live" MODULE IF PREVIOUSLY DEPLOYED
            */
            IF (C.sha1_live IS NOT NULL) THEN
                l_files.put('live/javascript/' || C.module_name, C.sha1_live);
            END IF;

            IF (C.build=0) THEN
                dbms_output.put_line('No change - ' || C.module_name);
                l_files.put(C.deploy_filename, C.sha1_test);
                CONTINUE;
            END IF;

            /*
            **  SOURCE TIMESTAMP CHANGE IS MORE RECENT THAN LAST DEPLOYMENT
            */
            SELECT apex_util.blob_to_clob(file_content) 
              INTO l_file_content 
              FROM apex_application_static_files 
             WHERE application_id=101 
               AND file_name=C.module_name;
            
            l_sha1_test:=LOWER(dbms_crypto.hash(src=>l_file_content, typ=>dbms_crypto.hash_sh1));

            /* CHECK THERE ACTUALLY WAS A CONTENT CHANGE */
            IF (l_sha1_test=C.sha1_test) THEN
                l_files.put(C.deploy_filename, C.sha1_test);
                CONTINUE;
            END IF;
            
            UPDATE es_modules
               SET updated_source=C.updated_date,
                   sha1_test=l_sha1_test,
                   updated_test=current_timestamp
             WHERE module_name=C.module_name;
             
            addDeploy(C.deploy_filename, l_file_content);
        END LOOP;
        
        buildImportmaps;

        FOR C IN (
            WITH source AS
            (
                SELECT '_headers' AS deploy_filename, 
                        '/*' || chr(10) || 
                        'Access-Control-Allow-Origin: *' || chr(10) || 
                        'Timing-Allow-Origin: *' AS content
                  FROM dual
            )
            SELECT s.deploy_filename, s.content, f.sha1
              FROM source s, website_files f
             WHERE f.website_id(+)=l_website_id
               AND f.path(+)=s.deploy_filename
        ) LOOP
            l_sha1:=LOWER(dbms_crypto.hash(src => TO_CLOB(C.content), typ => dbms_crypto.hash_sh1));
            IF (C.sha1 IS NULL OR l_sha1<>C.sha1) THEN
                addDeploy(C.deploy_filename, C.content);
            ELSE
                l_files.put(C.deploy_filename, C.sha1);
            END IF;
        END LOOP;

        -- pck_core.log(l_files.to_string);
        -- RETURN;

        sendNetlifyDeploy;

        /*
        ** WAIT FOR DEPLOYMENT OF ES-MODULES TO COMPLETE
        */
        pck_hosting.waitDeployment(pWebsiteid=>l_website_id, pUserid=>l_user_id, pWaitSeconds=>100);

        /*
        ** DELETE OLD DEPLOYMENTS OF ES-MODULES.NETLIFY.APP
        */
        pck_deploy.runDelete(pUserId=>l_user_id, pWebsiteId=>l_website_id, pSiteId=>l_netlify_site_id);

        EXCEPTION
            WHEN OTHERS THEN
                pck_core.log_error;
    END;
    
end;
/