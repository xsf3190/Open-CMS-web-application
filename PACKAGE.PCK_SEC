CREATE OR REPLACE EDITIONABLE PACKAGE "PCK_SEC" AS 
    --
    PROCEDURE createAuthPasscode(pWebsiteId IN website.id%type, pBodyText IN CLOB);
    --
    PROCEDURE verifyAuthPasscode(pWebsiteId IN website.id%type, pBodyText IN CLOB);
    --
    PROCEDURE makeAuthRequest(pWebsiteId IN website.id%type);
    --
    PROCEDURE refreshAuthToken(pWebsiteId IN website.id%type);
    --
    PROCEDURE post_auth_facebook;
    --
    PROCEDURE post_auth_google;
    --
    -- Implementing Base64URL docede - URL safe Base64
    FUNCTION BASE64URL_DECODE(p_input IN varchar2) RETURN RAW DETERMINISTIC PARALLEL_ENABLE;
    -- Convert RSA modulus (n) and exponent (e) that JWKS returns into Base64 encoded PKCS1 public key format that DBMS_CRYPTO expects
    FUNCTION MAKE_PKCS1_RSA_KEY(v_key_modulus_binary IN RAW /* raw(256) 2048 bits*/, v_public_key_exponent_binary IN RAW /* raw(3) 24 bits*/) RETURN RAW DETERMINISTIC PARALLEL_ENABLE;
    -- Go to ISS and fetch the public keys
    PROCEDURE UPDATE_JWKS_KEY_CACHE(p_iss IN VARCHAR2);
    -- Returns FALSE if there are problems with validation or signature, TRUE if JWT is valid (not expired, correct ISS) and signature is valid
    FUNCTION DECODE_AND_VALIDATE(p_jwt IN VARCHAR2, p_iss IN VARCHAR2, p_aud IN VARCHAR2, p_payload OUT VARCHAR2) RETURN boolean;
    --
    PROCEDURE subscribe;
    --
END PCK_SEC;
/
CREATE OR REPLACE EDITIONABLE PACKAGE BODY "PCK_SEC" AS

    REFRESH_TOKEN_EXP CONSTANT PLS_INTEGER:=(24*60*60)*90; --90 DAYS
    ACCESS_TOKEN_EXP CONSTANT PLS_INTEGER:=60*5; --90 DAYS


    PROCEDURE sendMessage(pSuccess IN BOOLEAN, pMessage IN VARCHAR2) IS
    BEGIN
        APEX_JSON.open_object;
        APEX_JSON.write ('success', pSuccess);
        APEX_JSON.write ('message', pMessage);
        APEX_JSON.close_object;
    END;

    /*
    ** USER SUBMITS EMAIL ADDRESS TO BE AUTHENTICATED
    ** - CREATE RANDOM PASSCODE 
    ** - SEND TO EMAIL ADDRESS
    */

    PROCEDURE createAuthPasscode(pWebsiteId IN website.id%type, pBodyText IN CLOB) IS
        l_email users.email%type;
        l_url varchar2(100);
        l_user_id users.id%type;
        l_digits   CONSTANT VARCHAR2(10) := '0123456789';
        l_passcode VARCHAR2(6);
        l_passcode_hash raw(32);
        l_json JSON_OBJECT_T;
        l_email_payload CLOB;
        l_favicon_url VARCHAR2(200);
        l_clob CLOB;
    BEGIN
        FOR C IN (SELECT j.email, j.url, NVL(u.id,0) user_id, a.cld_cloud_name, a.resource_type, a.public_id, a.format--, w.color_primary
                    FROM asset a, website w, users u, JSON_TABLE(pBodyText, '$' COLUMNS email, url) j
                   WHERE w.id=pWebsiteId
                     AND u.email(+)=j.email
                     AND a.id(+)=w.favicon_asset_id) 
        LOOP
            l_email:=C.email;
            l_url:=C.url;
            l_user_id:=C.user_id;
            IF (C.cld_cloud_name IS NOT NULL) THEN
                l_favicon_url:=pck_media.getCloudinaryUrl(C.cld_cloud_name,C.resource_type,C.public_id,C.format, 96) || '.png';
                l_favicon_url:=REPLACE(l_favicon_url,'q_auto,f_auto','f_auto,w_96,h_96');
            END IF;
        END LOOP;

        FoR i IN 1..6 LOOP
            l_passcode:=l_passcode || SUBSTR(l_digits,FLOOR(DBMS_RANDOM.VALUE(1, LENGTH(l_digits) + 1)),1);
        END LOOP;

        /* Store passcode as hash for later comparison with user-entered value */
        l_passcode_hash:=dbms_crypto.hash(src=>UTL_I18N.STRING_TO_RAW(l_passcode,'AL32UTF8'), typ=>dbms_crypto.hash_sh256);

        IF (l_user_id=0) THEN
            INSERT INTO users (email, passcode) VALUES (l_email, l_passcode_hash);
        ELSE
            UPDATE users SET passcode=l_passcode_hash WHERE id=l_user_id;
        END IF;

        /* Send mail to email address with passcode */
        l_json:=new JSON_OBJECT_T;
        l_json.put('contactEmail',l_email);
        l_json.put('subject','Passcode '||l_passcode||' will authenticate you on ' || l_url);
        l_json.put('body', '<html><body>' || CASE WHEN l_favicon_url IS NOT NULL THEN '<img src="'||l_favicon_url||'">' END|| '<h1>Passcode is ' || l_passcode || '</h1></body></html>');
        l_json.put('sourceEmail','authenticate@adfreesites.com');
        l_email_payload:=l_json.stringify;
        pck_api.callAWSemailAPI(pMethod=>'POST', pBody=>l_email_payload, pData=>l_clob);

        sendMessage(TRUE,'Passcode was sent to your inbox from authenticate@adfreesites.com');

        EXCEPTION WHEN OTHERS THEN
            pck_core.log_error;
    END;

    PROCEDURE getKeyAndScope(pWebsiteId IN website.id%type, pEmail IN VARCHAR2, pJwtEncKey IN OUT website.jwt_enc_key%type, pScope IN OUT VARCHAR2) 
    IS
        l_scope VARCHAR2(7);
        l_jwt_enc_key website.jwt_enc_key%type;
        l_contact_email website.contact_email%type;
    BEGIN
        SELECT jwt_enc_key, contact_email 
          INTO pJwtEncKey, l_contact_email
          FROM website
         WHERE id=pWebsiteId;
        
        IF (l_contact_email=pEmail) THEN 
            l_scope:='contact';
        ELSE 
            FOR C IN (SELECT null FROM website w, users u WHERE w.id=pWebsiteId AND u.id=w.user_id AND u.email=pEmail) LOOP
                l_scope:='admin';
            END LOOP;
        END IF;
        
        pScope:=NVL(l_scope,'user');

    END;

    FUNCTION getEncKey(pWebsiteId IN website.id%type) RETURN VARCHAR2 IS
        l_jwt_enc_key website.jwt_enc_key%type;
    BEGIN
        SELECT jwt_enc_key INTO l_jwt_enc_key FROM website WHERE id=pWebsiteId;
        RETURN (l_jwt_enc_key);
    END;

    /*
    ** VERIFY PASSCODE ENTERED BY USER MATCHES
    ** RETURN JWT ACCESS AND REFRESH TOKENS IF PASSCODES MATCH
    */
    PROCEDURE verifyAuthPasscode(pWebsiteId IN website.id%type, pBodyText IN CLOB) IS
        l_email users.email%type;
        l_user_id users.id%type;
        l_jwt_enc_key website.jwt_enc_key%type;
        l_passcode VARCHAR2(6);
        l_passcode_hash raw(32);
        l_token VARCHAR2 (4000);
        l_refresh VARCHAR2 (4000);
        l_scope VARCHAR2 (5);
    BEGIN
        FOR C IN (SELECT j.email, j.passcode passcode_entered, u.passcode passcode_emailed, u.id user_id
                    FROM users u, JSON_TABLE(pBodyText, '$' COLUMNS email, passcode) j
                   WHERE u.email=j.email) 
        LOOP
            l_email:=C.email;
            l_user_id:=C.user_id;
            l_passcode_hash:=dbms_crypto.hash(src=>UTL_I18N.STRING_TO_RAW(C.passcode_entered,'AL32UTF8'), typ=>dbms_crypto.hash_sh256);
            IF (l_passcode_hash<>C.passcode_emailed) THEN
                sendMessage(FALSE,'Passcodes do not match. Check your inbox and try again.');
                RETURN;
            END IF;
        END LOOP;

        IF (l_email IS NULL) THEN
            sendMessage(FALSE,'Something not right. Either email not sent or user not created.');
            RETURN;
        END IF;

        getKeyAndScope(pWebsiteId, l_email, l_jwt_enc_key, l_scope);

        l_token:=apex_jwt.ENCODE (
            p_iss       => 'ORDS',
            p_sub       => l_email,
            p_aud       => l_scope,
            p_jti       => TO_CHAR(l_user_id),
            p_iat_ts    => current_timestamp,
            p_exp_sec   => ACCESS_TOKEN_EXP,
            p_signature_key => UTL_RAW.cast_to_raw (l_jwt_enc_key)
        );

        l_refresh:=apex_jwt.ENCODE (
            p_iss       => 'ORDS',
            p_sub       => l_email,
            p_aud       => l_scope,
            p_jti       => TO_CHAR(l_user_id),
            p_iat_ts    => current_timestamp,
            p_exp_sec   => REFRESH_TOKEN_EXP,
            p_signature_key => UTL_RAW.cast_to_raw (l_jwt_enc_key)
        );

        APEX_JSON.open_object;
        APEX_JSON.write ('success', TRUE);
        APEX_JSON.write ('token', l_token);
        APEX_JSON.write ('refresh', l_refresh);
        APEX_JSON.write ('message', 'Successfully Logged in');
        APEX_JSON.close_object;

        EXCEPTION WHEN OTHERS THEN
            pck_core.log_error;
    END;

    /*
    ** CREATE AND RETURN NEW ACCESS / REFRESH TOKEN PAIR
    ** CALLED WHEN ACCESS TOKEN HAS EXPIRED
    */
    PROCEDURE refreshAuthToken(pWebsiteId IN website.id%type) IS
        l_header_value VARCHAR2(4000);
        l_bearer_token VARCHAR2(4000);
        l_token APEX_JWT.T_TOKEN;
        l_jwt_enc_key website.jwt_enc_key%type;
        l_user_object APEX_JSON.T_VALUES;
        l_scope VARCHAR2(7);
        l_email users.email%type;
        l_user_id VARCHAR2(6);
        l_new_token VARCHAR2 (4000);
        l_new_refresh VARCHAR2 (4000);
    BEGIN
        /* 
        ** Client authenticates with Refresh token in order to obtain a new Access token
        */
        l_header_value := OWA_UTIL.get_cgi_env('Authorization');
        
        -- Check if the Authorization header exists and starts with 'Bearer '
        IF (l_header_value IS NULL OR INSTR(l_header_value, 'Bearer ') <> 1) THEN
            sendMessage(FALSE,'No bearer token in Authorization header');
            RETURN;
        END IF;

        l_bearer_token := SUBSTR(l_header_value, 8);

        /*
        ** Refresh token can only be used once. Access Denied otherwise.
        */
        INSERT INTO jwt_refresh_token (website_id, token) VALUES (pWebsiteId, l_bearer_token);

        --getKeyAndScope(pWebsiteId, l_email, l_jwt_enc_key, l_scope);
        l_jwt_enc_key:=getEncKey(pWebsiteId);
        
        l_token:=apex_jwt.DECODE (
            p_value   => l_bearer_token,
            p_signature_key   => UTL_RAW.cast_to_raw (l_jwt_enc_key));

        /* 
        ** if refresh token has expired means user hasn't logged on for long time 
        */
        BEGIN
            apex_jwt.VALIDATE (p_token => l_token, p_iss => 'ORDS');
            EXCEPTION WHEN VALUE_ERROR THEN
                sendMessage(TRUE,'login');
                RETURN;
        END;

        /* 
        ** Parse the received token payload and extract relevant properties 
        */
        apex_json.parse (l_user_object, l_token.payload);
        l_email:=apex_json.get_varchar2 (p_path => 'sub', p_values => l_user_object);
        l_scope:=apex_json.get_varchar2 (p_path => 'aud', p_values => l_user_object);
        l_user_id:=apex_json.get_varchar2 (p_path => 'jti', p_values => l_user_object);

        l_new_token:=apex_jwt.ENCODE (
            p_iss       => 'ORDS',
            p_sub       => l_email,
            p_aud       => l_scope,
            p_jti       => l_user_id,
            p_iat_ts    => current_timestamp,
            p_exp_sec   => ACCESS_TOKEN_EXP,
            p_signature_key => UTL_RAW.cast_to_raw (l_jwt_enc_key)
        );

        l_new_refresh:=apex_jwt.ENCODE (
            p_iss       => 'ORDS',
            p_sub       => l_email,
            p_aud       => l_scope,
            p_jti       => l_user_id,
            p_iat_ts    => current_timestamp,
            p_exp_sec   => REFRESH_TOKEN_EXP,
            p_signature_key => UTL_RAW.cast_to_raw (l_jwt_enc_key)
        );

        APEX_JSON.open_object;
        APEX_JSON.write ('success', TRUE);
        APEX_JSON.write ('token', l_new_token);
        APEX_JSON.write ('refresh', l_new_refresh);
        APEX_JSON.write ('message', 'Successful token refresh');
        APEX_JSON.close_object;

        EXCEPTION WHEN OTHERS THEN
            pck_core.log_error;
    END;

    /*
    ** USER MAKES AUTHENTICATED REQUEST USING THEIR JWT TOKEN
    */
    PROCEDURE makeAuthRequest(pWebsiteId IN website.id%type) IS
        l_header_value     VARCHAR2(4000);
        l_bearer_token     VARCHAR2(4000);
        l_token            APEX_JWT.T_TOKEN;
        l_user_object      APEX_JSON.T_VALUES;
        l_jwt_enc_key website.jwt_enc_key%type;
        l_scope            VARCHAR2(200);
        l_email            users.email%type;
    BEGIN
        --get the authorization header value from the request
        l_header_value := OWA_UTIL.get_cgi_env('Authorization');
        
        -- Check if the Authorization header exists and starts with 'Bearer '
        IF (l_header_value IS NULL OR INSTR(l_header_value, 'Bearer ') <> 1) THEN
            sendMessage(FALSE,'Error - no bearer token in Authorization header');
            RETURN;
        END IF;

        l_bearer_token := SUBSTR(l_header_value, 8);

        getKeyAndScope(pWebsiteId, l_email, l_jwt_enc_key, l_scope);

        --pck_core.log('DECODE');
        l_token:=apex_jwt.DECODE (
            p_value   => l_bearer_token,
            p_signature_key   => UTL_RAW.cast_to_raw (l_jwt_enc_key));

        --pck_core.log('VALIDATE');
        BEGIN
            apex_jwt.VALIDATE (p_token => l_token, p_iss => 'ORDS');
            EXCEPTION WHEN VALUE_ERROR THEN
                sendMessage(TRUE,'expired');
                RETURN;
        END;

        apex_json.parse (l_user_object, l_token.payload);

        IF NOT apex_json.does_exist (p_path => 'sub', p_values => l_user_object) THEN
            sendMessage(FALSE,'No user found in JWT Token');
            RETURN;
        ELSIF NOT apex_json.does_exist (p_path => 'aud', p_values => l_user_object) THEN
            sendMessage(FALSE,'No scope found in JWT Token');
            RETURN;
        END IF;

        l_scope:=apex_json.get_varchar2 (p_path => 'aud', p_values => l_user_object);
        l_email:=apex_json.get_varchar2 (p_path => 'sub', p_values => l_user_object);

        pck_core.log(l_scope||':'||l_email);
        APEX_JSON.open_object;
        APEX_JSON.write ('success', TRUE);
        APEX_JSON.write ('email', l_email);
        APEX_JSON.write ('scope', l_scope);
        APEX_JSON.close_object;

        EXCEPTION WHEN OTHERS THEN
            pck_core.log_error;
    END;

    FUNCTION BASE64URL_DECODE(p_input IN varchar2) RETURN RAW DETERMINISTIC PARALLEL_ENABLE AS
        PRAGMA UDF;
        v_pad_count NUMBER(1);
    BEGIN
        -- This decodes Base64URL encoded value to RAW
        v_pad_count:= 4 - mod(length(p_input), 4);
        IF v_pad_count = 4 THEN
            v_pad_count:= 0;
        END IF;
        RETURN utl_encode.base64_decode(
            UTL_I18N.STRING_TO_RAW(
                replace(
                    replace(
                        rpad(p_input, length(p_input) + v_pad_count, '=')
                    , '_', '/')
                , '-', '+')
            , 'AL32UTF8')
        );
    END;

    FUNCTION MAKE_PKCS1_RSA_KEY(v_key_modulus_binary IN RAW /* raw(256) 2048 bits*/, v_public_key_exponent_binary IN RAW /* raw(3) 24 bits*/) RETURN RAW DETERMINISTIC PARALLEL_ENABLE AS
        PRAGMA UDF;
        c_tag_INTEGER raw(1) := hextoraw('02'); -- ASN.1 Universal Primitive Tag: 02 (INTEGER)
        c_tag_SEQUENCE raw(1) := hextoraw('30'); -- ASN.1 Universal Constructed Tag: 16 (SEQUENCE)
        c_2_LENGTH_BYTES_NEEDED raw(1) := hextoraw('82');
        c_3_VALUE_BYTES raw(1) := hextoraw('03');
        c_257_VALUE_BYTES raw(2) := hextoraw('0101');
        c_266_VALUE_BYTES raw(2) := hextoraw('010A');
        c_LEADING_ZERO_OF_INTEGER raw(1) := hextoraw('00');
    BEGIN
        -- From https://asktom.oracle.com/pls/apex/asktom.search?tag=plsql-only-ways-to-do-json-token-validation#9547303400346607729
        -- https://stackoverflow.com/questions/18039401/how-can-i-transform-between-the-two-styles-of-public-key-format-one-begin-rsa
        -- RSA (256) PKCS#1
        RETURN utl_encode.base64_encode(
            utl_raw.concat(
                r1 => c_tag_SEQUENCE -- 1 byte Tag
                , r2 => c_2_LENGTH_BYTES_NEEDED -- 1 byte Length Bytes
                , r3 => c_266_VALUE_BYTES -- 2 bytes Length
                , r4 => c_tag_INTEGER -- 1 byte Tag
                , r5 => c_2_LENGTH_BYTES_NEEDED -- 1 byte Length Bytes
                , r6 => c_257_VALUE_BYTES -- 2 bytes Length
                , r7 => c_LEADING_ZERO_OF_INTEGER -- 1 byte
                , r8 => v_key_modulus_binary -- 256 bytes
                , r9 => c_tag_INTEGER -- 1 byte Tag
                , r10 => c_3_VALUE_BYTES -- 1 byte Length
                , r11 => v_public_key_exponent_binary -- 3 bytes
            )
        );
    END;

    PROCEDURE UPDATE_JWKS_KEY_CACHE(p_iss IN VARCHAR2) AS
        PRAGMA AUTONOMOUS_TRANSACTION;
        v_lock_handle varchar2(128);
    BEGIN
        -- This updates local jwks_key_cache from Google IDP
        -- Executed when JWT signing key is not found in table jwks_key_cache
        --
        -- Avoid simultaneoud executions
        dbms_lock.allocate_unique('APEX_JWT_RS256_JWKS_UPDATE', v_lock_handle);
        IF dbms_lock.request(lockhandle=>v_lock_handle, timeout=>6, release_on_commit=>true) IN (0,4) THEN
            MERGE INTO jwks_key_cache t
            USING (
                WITH jwks AS 
                (
                    SELECT jwks_uri FROM JSON_TABLE(apex_web_service.make_rest_request(p_iss || '/.well-known/openid-configuration', 'GET'), '$' COLUMNS (jwks_uri))
                )
                SELECT kid, kty, e, alg, n
                FROM jwks, JSON_TABLE(apex_web_service.make_rest_request(jwks_uri, 'GET'), '$.keys[*]' COLUMNS (kid, kty, e, alg, n)) 
                ) s
            ON (s.kid = t.kid)
            WHEN NOT MATCHED THEN
                INSERT (kid, alg, kty, e, n, pkcs1)
                VALUES (s.kid, s.alg, s.kty, s.e, s.n,
                    make_pkcs1_rsa_key(base64url_decode(s.n), base64url_decode(s.e)));
            COMMIT;
        END IF;
    END;

    FUNCTION DECODE_AND_VALIDATE(p_jwt IN VARCHAR2, p_iss IN VARCHAR2, p_aud IN VARCHAR2, p_payload OUT VARCHAR2) RETURN boolean IS
        l_token apex_jwt.t_token;
        l_json_content json_object_t;
        l_kid jwks_key_cache.kid%type;
        l_key jwks_key_cache.pkcs1%type;
    BEGIN
        -- This will split and decode JWT token
        l_token := apex_jwt.decode(p_jwt);

        -- This will check if token has not expired and contains expected issued and audience
        BEGIN
            apex_jwt.validate(p_token=>l_token, p_iss=>p_iss, p_aud=>p_aud);
            EXCEPTION WHEN VALUE_ERROR THEN
                pck_core.log('Token validation error - check issuer or timeout');
                RETURN FALSE;
        END;

        -- Parsing the header to see if it is signed using RS256
        l_json_content:= json_object_t.parse(l_token.header);
        IF l_json_content.get_string('alg') != 'RS256' THEN
            pck_core.log('Only RS256 signed JWT tokens allowed');
            RETURN FALSE;
        END IF;

        -- Try fetching the key from cache.
       l_kid:= l_json_content.get_string('kid');
        FOR i IN 1..2 LOOP
            -- If first time key is not in cache, then update key cache from ISS.
            -- If second time key is also not present, then something is wrong and just fail.
            BEGIN
                SELECT pkcs1 INTO l_key FROM jwks_key_cache WHERE kid = l_kid;
                EXIT;
            EXCEPTION
                WHEN no_data_found THEN
                    IF i = 1 THEN
                        update_jwks_key_cache(p_iss);
                    ELSE
                        pck_core.log('Required key not found in JWKS cache table');
                        RETURN FALSE;
                    END IF;
            END;
        END LOOP;

        -- Validate the signature
        IF NOT DBMS_CRYPTO.VERIFY(
                src => UTL_I18N.STRING_TO_RAW(
                        SUBSTR(p_jwt, 1, INSTR(p_jwt, '.', 1, 2)-1) -- Operate on the input string itself, since v_token is already decoded, but JWT signs the encoded message
                    , 'al32utf8'), 
                sign => base64url_decode(l_token.signature),
                pub_key => l_key,
                pubkey_alg => dbms_crypto.KEY_TYPE_RSA,
                sign_alg => dbms_crypto.SIGN_SHA256_RSA)
        THEN
            pck_core.log('JWT signature failed cryptographic verification');
            RETURN FALSE;
        END IF;

        -- Signature is valid - return decoded JWT payload
        p_payload:= l_token.payload;
        RETURN TRUE;
    EXCEPTION
        WHEN others THEN
            -- In case of any exception, usually from APEX_JWT.validate or DBMS_CRYPTO - fail
            pck_core.log_error; RAISE;
    END;
    
    PROCEDURE subscribe IS
        l_header_value     VARCHAR2(4000);
        l_bearer_token     VARCHAR2(4000);
        l_token            APEX_JWT.T_TOKEN;
        l_valid_token       BOOLEAN;
        l_jwt_payload       VARCHAR2(2000);
        l_user_object      APEX_JSON.T_VALUES;
        l_email            users.email%type;
        l_iss              VARCHAR2(250):='https://accounts.google.com';
        l_google_client_id users.google_client_id%type;
    BEGIN
        --get the authorization header value from the request
        l_header_value := OWA_UTIL.get_cgi_env('Authorization');
        
        -- Check if the Authorization header exists and starts with 'Bearer '
        IF (l_header_value IS NULL OR INSTR(l_header_value, 'Bearer ') <> 1) THEN
            APEX_JSON.open_object;
            APEX_JSON.write ('success', FALSE);
            APEX_JSON.write ('message', 'Error - no bearer token in Authorization header');
            APEX_JSON.close_object;
            RETURN;
        END IF;


        /* Get Admmin user's Google client id name (repository owner) */
        SELECT u.google_client_id
          INTO l_google_client_id
          FROM apex_workspace_apex_users w, users u 
         WHERE w.email=u.email
           AND w.is_admin='Yes'
           FETCH FIRST ROW ONLY;

        -- Extract and validate the JWT token
        l_bearer_token := SUBSTR(l_header_value, 8);
        IF (decode_and_validate(l_bearer_token, l_iss, l_google_client_id, l_jwt_payload)) THEN
            apex_json.parse (l_user_object, l_jwt_payload);
            l_email:=apex_json.get_varchar2 (p_path => 'email', p_values => l_user_object);

            MERGE INTO users t
            USING (SELECT email, name FROM JSON_TABLE(l_jwt_payload, '$' COLUMNS (email, name)) ) s
            ON (s.email = t.email)
            WHEN MATCHED THEN UPDATE
                SET t.last_login_date=current_timestamp, t.last_login_provider=l_iss
            WHEN NOT MATCHED THEN
                INSERT (email, name, last_login_date, last_login_provider)
                VALUES (s.email, s.name, current_timestamp, l_iss);
            COMMIT;

            APEX_JSON.open_object;
            APEX_JSON.write ('success', TRUE);
            APEX_JSON.write ('email', l_email);
            APEX_JSON.close_object;
        ELSE
            APEX_JSON.open_object;
            APEX_JSON.write ('success', FALSE);
            APEX_JSON.write ('message', 'Error - invalid token');
            APEX_JSON.close_object;
        END IF;
    END;
  
    /*
    ** This procedure is called in the Post-authentication of Social Sign-in processing.
    ** First-time authenticated users are inserted into the USERS table
    */
    PROCEDURE insert_user_login(p_auth_provider IN VARCHAR2, p_email IN VARCHAR2, p_name IN VARCHAR2) IS
        l_user_id users.id%type;
        --l_user_name users.name%type;
        --l_client_tz users.client_tz%type;
        --l_client_tz_session users.client_tz%type:=apex_util.get_session_state('APP_CLIENT_TZ');
        l_workspace_id apex_workspaces.workspace_id%type;
    BEGIN
        SELECT workspace_id
          INTO l_workspace_id
          FROM apex_workspaces
         WHERE workspace = (
                SELECT workspace
                FROM apex_applications
                WHERE application_id = APEX_APPLICATION.G_FLOW_ID
                );
        /*
        FOR C IN (
            SELECT apex_session_id
              FROM apex_workspace_sessions
             WHERE workspace_id = l_workspace_id
               AND user_name = APEX_APPLICATION.G_USER
               AND apex_session_id != APEX_APPLICATION.G_INSTANCE
        )
        LOOP
            apex_session.delete_session(p_session_id => C.apex_session_id);
            DELETE session_data WHERE session_id=C.apex_session_id;
        END LOOP;
        */

        INSERT INTO user_login(auth_provider,email,name,apex_session_id) VALUES (p_auth_provider, p_email, p_name, APEX_APPLICATION.G_INSTANCE);

        BEGIN
            SELECT id
              INTO l_user_id
              FROM users 
             WHERE email=p_email;

            UPDATE users 
               SET name=p_name, last_login_date=current_timestamp, last_login_provider=p_auth_provider 
             WHERE id=l_user_id;

            EXCEPTION WHEN NO_DATA_FOUND 
            THEN
                INSERT INTO users(email, name, last_login_date, last_login_provider) 
                VALUES (p_email, p_name, current_timestamp, p_auth_provider);
        END;
        COMMIT;
    END;    

    PROCEDURE post_auth_facebook IS
    BEGIN
        insert_user_login('Facebook', apex_json.get_varchar2('email'), apex_json.get_varchar2('name'));
        EXCEPTION WHEN OTHERS THEN pck_core.log_error; RAISE;
    END;

    PROCEDURE post_auth_google IS
    BEGIN
        insert_user_login('Google', apex_json.get_varchar2('email'), apex_json.get_varchar2('name'));
        EXCEPTION WHEN OTHERS THEN pck_core.log_error; RAISE;
    END; 

    /* 
    ** Linked-In API has separate entry points for profile name and email addres.
    ** Support very rude. API is bollocks. Gave up on Linkedin but keep the code just in case
    */
    /*
    PROCEDURE post_auth_linkedin IS
        l_name users.name%type;
        l_email users.email%type;
        l_clob CLOB;
        l_names owa_cookie.vc_arr;
        l_vals owa_cookie.vc_arr;
        l_num_vals INTEGER;
    BEGIN
        pck_cms.log('starting'); 
        l_name:=apex_json.get_varchar2('localizedFirstName') || ' ' || apex_json.get_varchar2('localizedLastName');

        apex_web_service.g_request_headers.delete();
        pck_cms.log('Before make_rest_request');
        l_clob := apex_web_service.make_rest_request(
            p_url => 'https://api.linkedin.com/v2/emailAddress?q=members&projection=(elements*(handle~))',
            p_http_method => 'GET',
            p_credential_static_id => 'Linkedin',
            p_token_url => 'https://www.linkedin.com/oauth/v2/accessToken');
        pck_cms.log(l_clob);

        SELECT emailAddress INTO l_email 
          FROM JSON_TABLE(l_clob format json, '$'
            COLUMNS emailAddress VARCHAR2(100)  PATH '$.elements[0]."handle~".emailAddress');    

        apex_application.g_user:=l_email;

        insert_user_login('Linkedin', l_email, l_name);        
    END;   
    */

    /*
    **  Gave up on Azure too - can't remember why though.
    */
    /*
    PROCEDURE post_auth_azure IS
    BEGIN
        insert_user_login('Azure', apex_json.get_varchar2('userPrincipalName'), apex_json.get_varchar2('givenName') || ' ' || apex_json.get_varchar2('surname'));
    END; 
    */

END PCK_SEC;
/