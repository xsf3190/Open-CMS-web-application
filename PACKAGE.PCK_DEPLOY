CREATE OR REPLACE EDITIONABLE PACKAGE "PCK_DEPLOY" as 
    --
    PROCEDURE deployInfrastructure;
    --
    PROCEDURE deployWebsite(pWebsiteId IN website.id%type);
    --
    PROCEDURE getDeploymentStatus(pWebsiteId IN website.id%type);
    --
    PROCEDURE logDeployment(pBodyText IN CLOB, pWebsiteId IN website.id%type);
    --
end;
/
CREATE OR REPLACE EDITIONABLE PACKAGE BODY "PCK_DEPLOY" as 
    
    /*
    ** Build and deploy website to Netlify by submitting Github action
    */    
    PROCEDURE deployWebsite(pWebsiteId IN website.id%type) IS
        l_clob CLOB;
        l_json_clob CLOB;
        l_user_id website.user_id%type;
        l_domain_name website.domain_name%type;
        l_template website.template%type;
        l_contact_email website.contact_email%type;
        l_netlify_site_id website.netlify_site_id%type;
        l_github_repos_owner users.github_repos_owner%type;
        l_netlify_installation_id users.netlify_installation_id%type;
        l_placeholder BLOB:=HEXTORAW('00');
        l_repo_id INTEGER;
        l_deploy_key_id VARCHAR2(40);
        l_json JSON_OBJECT_T;
        l_repo JSON_OBJECT_T;
        l_action JSON_OBJECT_T;
        l_app_id NUMBER;
        l_session_id NUMBER;
        l_page_id NUMBER;
        n PLS_INTEGER;
    BEGIN
        l_user_id:=pck_core.getUserId();

        /* Get deployment details including Netlify site id */
        SELECT domain_name, template, contact_email, netlify_site_id
          INTO l_domain_name, l_template, l_contact_email, l_netlify_site_id
          FROM website
         WHERE id=pWebsiteId
           AND user_id=l_user_id;

        /* Check website template exists in Repository */
        pck_core.callGithubAPI(pUserId=>l_user_id, pEndpoint=>'contents/TEMPLATES', pMethod=>'GET', pData=>l_clob);

        SELECT COUNT(*) INTO n FROM dual WHERE EXISTS (SELECT name FROM JSON_TABLE(l_clob, '$[*]' COLUMNS (name)) WHERE name=l_template);
        IF (n<>1) THEN
            RAISE_APPLICATION_ERROR(-20021,'TEMPLATE ' || l_template || ' - NOT FOUND IN DEPLOY REPOSITORY');
        END IF;

        /* Check Github folder(directory) exists for the website - Netlify site must be linked to the DEPLOY repository folder in order to enable auto-deploy */
        pck_core.callGithubAPI(pUserId=>l_user_id, pEndpoint=>'contents/'||l_domain_name, pMethod=>'GET', pData=>l_clob);

        IF (apex_web_service.g_status_code=404) THEN /* No Github directory */
            l_json:=new JSON_OBJECT_T;
            l_json.put('message','Commit by user id ' || l_user_id);
            l_json.put('content', APEX_WEB_SERVICE.BLOB2CLOBBASE64(l_placeholder)); /* Github insists on base64 string */
            l_json_clob:=l_json.to_clob;
            pck_core.callGithubAPI(pUserId=>l_user_id, pEndpoint=>'contents/'||l_domain_name || '/.placeholder', pMethod=>'PUT', pBody=>l_json_clob, pData=>l_clob);
        END IF;

        DELETE website_deploy WHERE website_id=pWebsiteId;
        logDeployment('{"status":"Starting Deployment"}',pWebsiteId);

        /*
        ** 1. Create Netlify Site with deployment id if not already exists
        ** 2. Trigger Github action build
        */

        IF (l_netlify_site_id IS NULL) THEN
            logDeployment('{"status":"Creating site in Netlify"}',pWebsiteId);

            /* get id of the DEPLOY github repository */
            pck_core.callGithubAPI(pUserId=>l_user_id, pEndpoint=>NULL, pMethod=>'GET', pData=>l_clob);
            FOR C IN (SELECT id FROM JSON_TABLE(l_clob, '$' COLUMNS (id))) LOOP
                l_repo_id:=C.id;
            END LOOP;

            /* get netlify deploy id */
            pck_core.callNetlifyAPI(pUserId=>l_user_id, pEndpoint=>'deploy_keys', pMethod=>'POST', pData=>l_clob);
            FOR C IN (SELECT id FROM JSON_TABLE(l_clob, '$' COLUMNS (id))) LOOP
                l_deploy_key_id:=C.id;
            END LOOP;

            /* create JSON payload for new Netlify site */
            l_json:=new JSON_OBJECT_T;
            l_json.put('name', l_domain_name);

            l_repo:=new JSON_OBJECT_T;
            l_repo.put('provider', 'github');
            l_repo.put('repo_type', 'git');
            l_repo.put('repo_id', l_repo_id);
            l_repo.put('repo', pck_core.getGithubReposOwner(l_user_id) || '/DEPLOY');
            l_repo.put('repo_branch', 'main');
            l_repo.put('private', FALSE);
            l_repo.put('deploy_key_id', l_deploy_key_id);
            l_repo.put('installation_id', pck_core.getNetlifyIntallationId(l_user_id));
            l_repo.put('base', l_domain_name);   
            l_json.put('repo', l_repo);

            /* Create Netlify site and store the site_id in website table */
            pck_core.callNetlifyAPI(pUserId=>l_user_id, pEndpoint=>'sites', pMethod=>'POST', pBody=>l_json.stringify, pData=>l_clob);
            pck_core.log(l_clob);
            FOR C IN (SELECT site_id FROM JSON_TABLE(l_clob, '$' COLUMNS (site_id))) LOOP
                UPDATE website SET netlify_site_id = C.site_id WHERE id=pWebsiteId;
            END LOOP;
            logDeployment('{"status":"Netlify site created and linked to github"}',pWebsiteId);
        END IF;

        /* Include apex session header in the payload sent to Github action - this will be used to authenticate subsequent content retrieval in the action Eleventy code path */
        pck_core.getApexSession(l_app_id,l_session_id,l_page_id);

        /* trigger deployment by dispatching Github action */          
        l_json:=new JSON_OBJECT_T;
        l_json.put('event_type', 'trigger_build');

        l_action:=new JSON_OBJECT_T;
        l_action.put('build_path', l_domain_name);
        l_action.put('template', l_template);
        l_action.put('fetch_url', pck_core.getRestUrl() || 'content/' || pWebsiteId);  
        l_action.put('log_url', pck_core.getRestUrl() || 'deploy-status/' || pWebsiteId);
        l_action.put('apex_session', l_app_id || ',' || l_session_id || ',' || l_page_id);
        l_json.put('client_payload', l_action);

        /* nb; Github API 'dispatches' endpoint does not send a response */
        l_json_clob:=l_json.stringify;
        pck_core.callGithubAPI(pUserId=>l_user_id, pEndpoint=>'dispatches', pMethod=>'POST', pBody=>l_json_clob, pData=>l_clob);

        apex_json.open_object; 
        apex_json.write('success', TRUE);
        apex_json.close_object;

        EXCEPTION
            WHEN OTHERS THEN
                pck_core.log_error;
    END;

    /*
     **  Insert row in website_deploy logging table
     **  1) Invoked via curl from Github Action
     **  2) called internally within this package to log Netlify actions
     */      
    PROCEDURE logDeployment(pBodyText IN CLOB, pWebsiteId IN website.id%type) IS 
        l_exitcode PLS_INTEGER;
        l_status website_deploy.status%type;
    BEGIN
        SELECT status 
          INTO l_status
          FROM JSON_TABLE(pBodyText, '$' COLUMNS (status));

        l_exitcode:=owa_util.get_cgi_env('QUERY_STRING');

        IF (l_exitcode IS NOT NULL) THEN
            IF (l_exitcode=0) THEN
                l_status:=l_status || ' - OK';
            ELSE
                l_status:=l_status || ' - NOK';
            END IF;
        END IF;

        INSERT INTO website_deploy(id, website_id, status) VALUES (seq_log.nextval, pWebsiteId, l_status );
        COMMIT;

        EXCEPTION
            WHEN OTHERS THEN
                pck_core.log_error;
    END;    


    /*
     **  Get deployment status from website_deploy logging table
     */      
    PROCEDURE getDeploymentStatus(pWebsiteId IN website.id%type) IS 
        l_user_id users.id%type;
        l_status CLOB;
        l_clob CLOB;
        l_ssl_url VARCHAR2(100);
        l_deployment_complete BOOLEAN:=FALSE;
        l_netlify_status website_deploy.status%type;
    BEGIN
        l_user_id:=pck_core.getUserId();

        /* If github action completed get latest Netlify deployment status and add this to the website_deploy table */

        FOR C IN (SELECT w.netlify_site_id, wd.log_time
                    FROM website w, website_deploy wd
                   WHERE w.id=pWebsiteId 
                     AND w.user_id=l_user_id
                     AND wd.website_id=w.id
                     AND wd.status='Github action completed - OK') 
        LOOP
            pck_core.callNetlifyAPI(pUserId=>l_user_id, pEndpoint=>'sites/'|| C.netlify_site_id || '/deploys', pMethod=>'GET', pData=>l_clob);

            --l_clob := apex_web_service.make_rest_request(p_url=>'https://api.netlify.com/api/v1/sites/' || C.netlify_site_id || '/deploys', p_http_method=>'GET');


            FOR C1 IN (SELECT state, ssl_url, error_message, created_at
                         FROM JSON_TABLE(l_clob, '$[0]' COLUMNS (state, ssl_url, created_at, error_message))) 
            LOOP
                IF (to_timestamp(C1.created_at,'yyyy-mm-dd"T"hh24:mi:ss.ff3"Z"') >= C.log_time) THEN
                    IF (C1.state='ready') THEN
                        l_deployment_complete:=TRUE;
                        l_ssl_url:=C1.ssl_url;
                    END IF;
                    l_netlify_status:='Netlify ' || C1.state || ' - ' || CASE WHEN C1.error_message IS NULL THEN 'OK' ELSE 'NOK' END;
                    DELETE website_deploy WHERE website_id=pWebsiteId AND status=l_netlify_status;
                    logDeployment('{"status":"' || l_netlify_status || '"}',pWebsiteId);
                END IF;
            END LOOP;
        END LOOP;

        /* return list of all deployment status to client */
        FOR C IN (SELECT id, status, ROUND((next_log_time - log_time)*86400) ela_sec
                    FROM 
                        (
                         SELECT id, status, log_time, NVL(LEAD(log_time) OVER (ORDER BY id),current_date) next_log_time
                           FROM website_deploy 
                          WHERE website_id=pWebsiteId
                        )
                   ORDER BY id) 
        LOOP
            l_status:=l_status || TO_CLOB('<span>' || C.status || ' - ' || C.ela_sec || ' seconds</span><br>');
            IF (SUBSTR(C.status,-3)='NOK') THEN
                l_deployment_complete:=TRUE;
                EXIT;
            END IF;
        END LOOP;

        IF (l_ssl_url IS NOT NULL) THEN
            l_status:=l_status || TO_CLOB('<a target="_blank" href="' || l_ssl_url || '">' || l_ssl_url || '<a>');
        END IF;

        apex_json.open_object; 
        apex_json.write('success', TRUE);
        apex_json.write('completed', l_deployment_complete);
        apex_json.write('status', l_status);
        apex_json.close_object;

        EXCEPTION
            WHEN OTHERS THEN
                pck_core.log_error;
    END;  

    /*
    ** Build and deploy infrastructure through Terraform by submitting Github action. 
    ** Do this once and each time we recycle the public key that is used to sign a website's contact email
    */
    PROCEDURE deployInfrastructure IS
        l_clob CLOB;
        l_json_clob CLOB;
        l_user_id users.id%type;
        l_json JSON_OBJECT_T;
        l_action JSON_OBJECT_T;
    BEGIN
        l_user_id:=pck_core.getUserId();

        FOR C IN (SELECT terraform_token, replace(utl_raw.cast_to_varchar2(utl_encode.base64_encode(utl_raw.cast_to_raw(terraform_public_key))),chr(13)||chr(10),null) terraform_public_key
                    FROM users
                   WHERE id=l_user_id) 
        LOOP
            /* trigger the deployment using Githib action */          
            l_json:=new JSON_OBJECT_T;
            l_json.put('event_type', 'trigger_build_infra');

            l_action:=new JSON_OBJECT_T;
            l_action.put('from_email', 'funnyface@markrussellbrown.com');
            l_action.put('public_key', C.terraform_public_key);
            l_action.put('terraform_token', C.terraform_token);
            l_json.put('client_payload', l_action);

            --l_clob := apex_web_service.make_rest_request(p_url=>'https://api.github.com/repos/'|| C.deploy_repo || '/dispatches' ,p_http_method=>'POST',p_body=>l_json.stringify);

            /* nb; Github API 'dispatches' endpoint does not send a response */
            l_json_clob:=l_json.stringify;
            pck_core.callGithubAPI(pUserId=>l_user_id, pEndpoint=>'dispatches', pMethod=>'POST', pBody=>l_json_clob, pData=>l_clob);

            apex_json.open_object; 
            apex_json.write('success', TRUE);
            apex_json.close_object;
        END LOOP;

        EXCEPTION
            WHEN OTHERS THEN
                pck_core.log_error;
    END;    

end;
/