CREATE OR REPLACE EDITIONABLE PACKAGE "PCK_DEPLOY" as 
    --
    PROCEDURE deleteDirectory(pWebsiteId IN website.id%type, pUserId IN users.id%type);
    --
    PROCEDURE deployInfrastructure;
    --
    PROCEDURE deployWebsite(pBodyText IN CLOB);
    --
    PROCEDURE updateDeploymentStatus(pWebsiteId IN website.id%type, pBodyText IN CLOB);
    --
    PROCEDURE logDeployment(pBodyText IN CLOB, pWebsiteId IN website.id%type);
    --
    PROCEDURE runDeployment(pWebsiteId IN website.id%type, pUserId IN website.user_id%type, pApexSession IN VARCHAR2, pRestURL IN VARCHAR2, pSiteId IN website.netlify_site_id%type);
end;
/
CREATE OR REPLACE EDITIONABLE PACKAGE BODY "PCK_DEPLOY" as 
    
    /*
    ** Build and deploy website to Netlify by submitting Github action
    */    
    PROCEDURE deployWebsite(pBodyText IN CLOB) IS
        l_template website.template%type;
        l_clob CLOB;
        l_job_name VARCHAR2(30);
        n PLS_INTEGER;
        l_body_text CLOB:=pBodyText;
        l_website_id website.id%type;
        l_site_id website.netlify_site_id%type;
        l_session_data pck_core.session_data_rt;
    BEGIN
        l_session_data:=pck_core.getSessionData();

        SELECT websiteid, siteid INTO l_website_id, l_site_id FROM users, JSON_TABLE(l_body_text, '$' COLUMNS (websiteid, siteid)) WHERE users.id=l_session_data.user_id;

        DELETE website_deploy WHERE website_id=l_website_id AND site_id=l_site_id;

        /* All content except first article, which is the home page, must have a navigation label */
        SELECT COUNT(*)
        INTO n
        FROM
        (
            SELECT MIN(display_order) OVER () first_display_order, navigation_label, display_order
            FROM website_article
            WHERE website_id=l_website_id
        )
        WHERE navigation_label IS NULL
        AND display_order<>first_display_order;

        IF (n>0) THEN
            logDeployment('{"site_id":"' || l_site_id || '","status":"Missing ' || n || ' Navigation Labels ... see View Options","exitcode":1}',l_website_id);
            apex_json.open_object; 
            apex_json.write('success', TRUE);
            apex_json.close_object;
            RETURN;
        END IF;

        /* Template must exist in Deploy repository */
        SELECT template
          INTO l_template
          FROM website
         WHERE id=l_website_id
           AND user_id=l_session_data.user_id;

        pck_api.callGithubAPI(pUserId=>l_session_data.user_id, pEndpoint=>'contents/TEMPLATES', pMethod=>'GET', pData=>l_clob);
        SELECT COUNT(*) INTO n FROM dual WHERE EXISTS (SELECT name FROM JSON_TABLE(l_clob, '$[*]' COLUMNS (name)) WHERE name=l_template);
        IF (n<>1) THEN
            logDeployment('{"site_id":"' || l_site_id || '","status":"TEMPLATE INCONSISTENCY","exitcode":1}',l_website_id);
            apex_json.open_object; 
            apex_json.write('success', TRUE);
            apex_json.close_object;
            RETURN;
        END IF;

        /* Check no other session currently building */
        IF (pck_api.setGithubCurrentBuild(l_session_data.user_id, l_session_data.session_id) IS NOT NULL) THEN
            logDeployment('{"site_id":"' || l_site_id || '","status":"Someone else is deploying ... try again later","exitcode":1}',l_website_id);
            apex_json.open_object;
            apex_json.write('success', TRUE);
            apex_json.close_object;
            RETURN;
        END IF;


        logDeployment('{"site_id":"' || l_site_id || '","status":"Submitting Deployment Job"}',l_website_id);

        /* Submit background job to run the deployment - can take some time depending on number of pages to build */
        l_job_name:=dbms_scheduler.generate_job_name('DEPLOY_');
        dbms_scheduler.create_job(
            job_name   => l_job_name,
            job_type   =>'STORED_PROCEDURE',
            job_action =>'pck_deploy.runDeployment',
            number_of_arguments=>5,
            start_date=>systimestamp
        );
        dbms_scheduler.set_job_argument_value(
            job_name => l_job_name,
            argument_position => 1,
            argument_value => l_website_id
        );
        dbms_scheduler.set_job_argument_value(
            job_name => l_job_name,
            argument_position => 2,
            argument_value => l_session_data.user_id
        );
        dbms_scheduler.set_job_argument_value(
            job_name => l_job_name,
            argument_position => 3,
            argument_value => l_session_data.app_id || ',' || l_session_data.session_id || ',' || l_session_data.page_id
        );
        dbms_scheduler.set_job_argument_value(
            job_name => l_job_name,
            argument_position => 4,
            argument_value => pck_core.getRestUrl()
        );
        dbms_scheduler.set_job_argument_value(
            job_name => l_job_name,
            argument_position => 5,
            argument_value => l_site_id
        );
        dbms_scheduler.enable(l_job_name);

        apex_json.open_object; 
        apex_json.write('success', TRUE);
        apex_json.close_object;
    END;


    PROCEDURE runDeployment(pWebsiteId IN website.id%type, pUserId IN website.user_id%type, pApexSession IN VARCHAR2, pRestURL IN VARCHAR2, pSiteId IN website.netlify_site_id%type) is
        l_domain_name website.domain_name%type;
        l_template website.template%type;
        l_clob CLOB;
        l_json_clob CLOB;

        l_github_repos_owner users.github_repos_owner%type;
        l_netlify_installation_id users.netlify_installation_id%type;
        l_placeholder BLOB:=HEXTORAW('00');
        l_repo_id INTEGER;
        l_deploy_key_id VARCHAR2(40);
        l_json JSON_OBJECT_T;
        l_repo JSON_OBJECT_T;
        l_action JSON_OBJECT_T;
    BEGIN
        logDeployment('{"site_id":"' || pSiteId || '","status":"Starting Deployment"}',pWebsiteId);

        SELECT domain_name, template
          INTO l_domain_name, l_template
          FROM website
         WHERE id=pWebsiteId
           AND user_id=pUserId;

        /* Github directory for the website must exist in DEPLOY repository in order to enable auto-deploy from Netlify */
        /* Have to handle case where domain name changed after deploy so we don't keep unused directories */

        pck_api.callGithubAPI(pUserId=>pUserId, pEndpoint=>'contents/'||l_domain_name, pMethod=>'GET', pStatusAllowed=>404, pData=>l_clob);
        IF (apex_web_service.g_status_code=404) THEN
            logDeployment('{"status":"Creating Github repository folder DEPLOY/' || l_domain_name || '"}',pWebsiteId);
            l_json:=new JSON_OBJECT_T;
            l_json.put('message','Commit by user id ' || pUserId);
            l_json.put('content', APEX_WEB_SERVICE.BLOB2CLOBBASE64(l_placeholder)); /* Github insists on base64 string */
            l_json_clob:=l_json.to_clob;
            pck_api.callGithubAPI(pUserId=>pUserId, pEndpoint=>'contents/'||l_domain_name || '/.placeholder', pMethod=>'PUT', pBody=>l_json_clob, pData=>l_clob);
        END IF;

        /*
        ** 1. Create Netlify Site with deployment id if not already exists
        ** 2. Trigger Github action build
        */
        --logDeployment('{"status":"Creating site in Netlify"}',pWebsiteId);

        /* get id of the DEPLOY github repository */
        pck_api.callGithubAPI(pUserId=>pUserId, pEndpoint=>NULL, pMethod=>'GET', pData=>l_clob);
        SELECT id INTO l_repo_id FROM JSON_TABLE(l_clob, '$' COLUMNS (id));

        /* get netlify deploy id */
        pck_api.callNetlifyAPI(pUserId=>pUserId, pEndpoint=>'deploy_keys', pMethod=>'POST', pData=>l_clob);
        SELECT id INTO l_deploy_key_id FROM JSON_TABLE(l_clob, '$' COLUMNS (id));

        /* create JSON payload for new Netlify site */
        l_repo:=new JSON_OBJECT_T;
        l_repo.put('provider', 'github');
        l_repo.put('repo_type', 'git');
        l_repo.put('repo_id', l_repo_id);
        l_repo.put('repo', pck_api.getGithubReposOwner(pUserId) || '/DEPLOY');
        l_repo.put('repo_branch', 'main');
        l_repo.put('private', FALSE);
        l_repo.put('deploy_key_id', l_deploy_key_id);
        l_repo.put('installation_id', pck_api.getNetlifyIntallationId(pUserId));
        l_repo.put('base', l_domain_name);   

        l_json:=new JSON_OBJECT_T;
        l_json.put('repo', l_repo);

        /* Link Netlify site to Github repository */
        pck_api.callNetlifyAPI(pUserId=>pUserId, pEndpoint=>'sites/' || pSiteId, pMethod=>'PATCH', pBody=>l_json.stringify, pData=>l_clob);
        logDeployment('{"site_id":"' || pSiteId || '","status":"Netlify site linked to github"}',pWebsiteId);

        /* trigger deployment by dispatching Github action */          
        l_json:=new JSON_OBJECT_T;
        l_json.put('event_type', 'trigger_build');

        l_action:=new JSON_OBJECT_T;
        l_action.put('build_path', l_domain_name);
        l_action.put('template', l_template);
        l_action.put('fetch_url', pRestURL || 'content/' || pWebsiteId);  
        l_action.put('log_url', pRestURL || 'deploy-status/' || pWebsiteId);
        l_action.put('apex_session', pApexSession);
        l_action.put('site_id', pSiteId);
        l_json.put('client_payload', l_action);

        /* Note that Github API 'dispatches' endpoint does not send a response */
        l_json_clob:=l_json.stringify;
        logDeployment('{"site_id":"' || pSiteId || '","status":"Triggering github action to build site"}',pWebsiteId);
        pck_api.callGithubAPI(pUserId=>pUserId, pEndpoint=>'dispatches', pMethod=>'POST', pBody=>l_json_clob, pData=>l_clob);

        EXCEPTION
            WHEN OTHERS THEN
                logDeployment('{"site_id":"' || pSiteId || '","status":"' || SUBSTR(SQLERRM,1,100) || '", "exitcode": 1}',pWebsiteId);
                pck_core.log_error;
    END;

    /*
     **  Insert row in website_deploy logging table
     **  1) Invoked via curl from Github Action
     **  2) called internally within this package to log Netlify actions
     */      
    PROCEDURE logDeployment(pBodyText IN CLOB, pWebsiteId IN website.id%type) IS 
        l_site_id website_deploy.site_id%type;
        l_exitcode PLS_INTEGER;
        l_status website_deploy.status%type;
        l_session_data pck_core.session_data_rt;
    BEGIN
        l_session_data:=pck_core.getSessionData();

        SELECT site_id, status, NVL(exitcode,0)
          INTO l_site_id, l_status, l_exitcode
          FROM JSON_TABLE(pBodyText, '$' COLUMNS (site_id, status, exitcode));

        INSERT INTO website_deploy(id, website_id, site_id, status) VALUES (seq_log.nextval, pWebsiteId, l_site_id, l_status || ' - ' || CASE WHEN l_exitcode=0 THEN 'OK' ELSE 'NOK' END);

        COMMIT;

        EXCEPTION
            WHEN OTHERS THEN
                pck_core.log_error;
    END;    


    /*
     **  Get deployment status from website_deploy logging table
     */
    PROCEDURE updateDeploymentStatus(pWebsiteId IN website.id%type, pBodyText IN CLOB) IS 
        l_site_id website_deploy.site_id%type;
        l_status CLOB;
        l_clob CLOB:=pBodyText;
        l_ssl_url VARCHAR2(100);
        l_deployment_complete BOOLEAN:=FALSE;
        l_netlify_status website_deploy.status%type;
        l_job_name VARCHAR2(30);
        l_session_data pck_core.session_data_rt;
    BEGIN
        l_session_data:=pck_core.getSessionData();

        SELECT site_id INTO l_site_id FROM JSON_TABLE(l_clob, '$' COLUMNS (site_id));

        /* If github action completed get latest Netlify deployment status and add this to the website_deploy table */

        FOR C IN (SELECT wd.log_time
                    FROM website w, website_deploy wd
                   WHERE w.id=pWebsiteId 
                     AND w.user_id=l_session_data.user_id
                     AND wd.website_id=w.id
                     AND wd.site_id=l_site_id
                     AND wd.status='Github action completed - OK') 
        LOOP
            pck_api.callNetlifyAPI(pUserId=>l_session_data.user_id, pEndpoint=>'sites/'|| l_site_id || '/deploys', pMethod=>'GET', pData=>l_clob);

            FOR C1 IN (SELECT state, ssl_url, error_message, created_at
                         FROM JSON_TABLE(l_clob, '$[0]' COLUMNS (state, ssl_url, created_at, error_message))) 
            LOOP
                IF (to_timestamp(C1.created_at,'yyyy-mm-dd"T"hh24:mi:ss.ff3"Z"') >= C.log_time) THEN
                    IF (C1.state='ready') THEN
                        l_deployment_complete:=TRUE;
                        l_ssl_url:=C1.ssl_url;
                    END IF;
                    l_netlify_status:='Netlify ' || C1.state;
                    DELETE website_deploy WHERE website_id=pWebsiteId AND status LIKE l_netlify_status||'%' AND site_id=l_site_id;
                    logDeployment('{"site_id":"' || l_site_id || '","status":"' || l_netlify_status || '","exitcode":' || CASE WHEN C1.error_message IS NULL THEN 0 ELSE 1 END || '}',pWebsiteId);
                END IF;
            END LOOP;
        END LOOP;

        /* return list of all deployment status to client */
        FOR C IN (SELECT id, status, ROUND((next_log_time - log_time)*86400) ela_sec
                    FROM 
                        (
                         SELECT id, status, log_time, NVL(LEAD(log_time) OVER (ORDER BY id),current_date) next_log_time
                           FROM website_deploy 
                          WHERE website_id=pWebsiteId
                            AND site_id=l_site_id
                        )
                   ORDER BY id) 
        LOOP
            l_status:=l_status || TO_CLOB('<span>' || C.status || ' - ' || C.ela_sec || ' seconds</span><br>');
            IF (SUBSTR(C.status,-3)='NOK') THEN
                l_deployment_complete:=TRUE;
                EXIT;
            END IF;
        END LOOP;

        IF (l_ssl_url IS NOT NULL) THEN
            FOR C IN (SELECT ROUND((MAX(log_time)-MIN(log_time))*86400) total_elapsed FROM website_deploy WHERE website_id=pWebsiteId AND site_id=l_site_id) LOOP
                l_status:=l_status || TO_CLOB('<span>DEPLOYMENT COMPLETE  - ' || C.total_elapsed || ' seconds</span><br>');
            END LOOP;
            l_status:=l_status || TO_CLOB('<a target="_blank" href="' || l_ssl_url || '">' || l_ssl_url || '<a>');
        END IF;

        IF (l_deployment_complete) THEN
            pck_api.callNetlifyAPI(pUserId=>l_session_data.user_id, pEndpoint=>'sites/'|| l_site_id || '/unlink_repo', pMethod=>'PUT', pData=>l_clob);

            /* Submit background job to delete Github build directory */
            l_job_name:=dbms_scheduler.generate_job_name('DELETE_');

            dbms_scheduler.create_job(
                job_name   => l_job_name,
                job_type   =>'STORED_PROCEDURE',
                job_action =>'pck_deploy.deleteDirectory',
                number_of_arguments=>2,
                start_date=>systimestamp
            );
            dbms_scheduler.set_job_argument_value(
                job_name => l_job_name,
                argument_position => 1,
                argument_value => pWebsiteId
            );
            dbms_scheduler.set_job_argument_value(
                job_name => l_job_name,
                argument_position => 2,
                argument_value => l_session_data.user_id
            );
            dbms_scheduler.enable(l_job_name);
        END IF;

        apex_json.open_object; 
        apex_json.write('success', TRUE);
        apex_json.write('completed', l_deployment_complete);
        apex_json.write('status', l_status);
        apex_json.close_object;

        EXCEPTION
            WHEN OTHERS THEN
                pck_core.log_error;
    END;   

    /*
    ** Delete Github build directory - have to delete files individually before Github removes directory
    */    
    PROCEDURE deleteDirectory(pWebsiteId IN website.id%type, pUserId IN users.id%type) IS
        l_clob CLOB;
        l_domain_name website.domain_name%type;
        l_github CLOB;
        l_json JSON_OBJECT_T;
    BEGIN
        SELECT domain_name INTO l_domain_name FROM website WHERE id=pWebsiteId;
        pck_api.callGithubAPI(pUserId=>pUserId, pEndpoint=>'contents/'||l_domain_name, pMethod=>'GET', pData=>l_clob);
        FOR C IN (SELECT name, sha, message FROM  JSON_TABLE(l_clob FORMAT JSON, '$[*]' COLUMNS (name, sha, message))) LOOP
            IF (C.message IS NOT NULL) THEN 
                pck_core.log(C.message);
                RAISE_APPLICATION_ERROR(-20050,'Error in deleteDirectory - '|| C.message);
            ELSE
                l_json:=JSON_OBJECT_T.parse('{"message":"Commit by PLSQL"}');
                l_json.put('sha',C.sha);
                l_github:=l_json.to_clob; 
                pck_api.callGithubAPI(pUserId=>pUserId, pEndpoint=>'contents/' || l_domain_name || '/'||C.name, pMethod=>'DELETE', pBody=>l_github, pData=>l_clob);
            END IF;
        END LOOP;
        pck_api.resetGithubCurrentBuild(pUserId);
    END;

    /*
    ** Build and deploy infrastructure through Terraform by submitting Github action. 
    ** Do this once and each time we recycle the public key that is used to sign a website's contact email
    */
    PROCEDURE deployInfrastructure IS
        l_clob CLOB;
        l_json_clob CLOB;
        l_json JSON_OBJECT_T;
        l_action JSON_OBJECT_T;
        l_session_data pck_core.session_data_rt;
    BEGIN
        l_session_data:=pck_core.getSessionData();

        FOR C IN (SELECT terraform_token, replace(utl_raw.cast_to_varchar2(utl_encode.base64_encode(utl_raw.cast_to_raw(terraform_public_key))),chr(13)||chr(10),null) terraform_public_key
                    FROM users
                   WHERE id=l_session_data.user_id) 
        LOOP
            /* trigger the deployment using Githib action */          
            l_json:=new JSON_OBJECT_T;
            l_json.put('event_type', 'trigger_build_infra');

            l_action:=new JSON_OBJECT_T;
            l_action.put('from_email', 'funnyface@markrussellbrown.com');
            l_action.put('public_key', C.terraform_public_key);
            l_action.put('terraform_token', C.terraform_token);
            l_json.put('client_payload', l_action);

            --l_clob := apex_web_service.make_rest_request(p_url=>'https://api.github.com/repos/'|| C.deploy_repo || '/dispatches' ,p_http_method=>'POST',p_body=>l_json.stringify);

            /* nb; Github API 'dispatches' endpoint does not send a response */
            l_json_clob:=l_json.stringify;
            pck_api.callGithubAPI(pUserId=>l_session_data.user_id, pEndpoint=>'dispatches', pMethod=>'POST', pBody=>l_json_clob, pData=>l_clob);

            apex_json.open_object; 
            apex_json.write('success', TRUE);
            apex_json.close_object;
        END LOOP;

        EXCEPTION
            WHEN OTHERS THEN
                pck_core.log_error;
    END;       
end;
/